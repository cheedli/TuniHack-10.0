<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR.js + A-Frame Demo</title>
  <!-- A-Frame library -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <!-- AR.js library for A-Frame -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <!-- Optional: A-Frame Extras for orbit or gesture controls -->
  <script src="https://unpkg.com/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>

  <!-- Simple gesture-handler component for pinch/drag interactions -->
  <script>
    AFRAME.registerComponent('gesture-handler', {
      schema: {
        rotationFactor: { default: 5 },
        minScale: { default: 0.3 },
        maxScale: { default: 8 },
      },
      init: function () {
        this.handleScale = this.handleScale.bind(this);
        this.handleRotation = this.handleRotation.bind(this);
        this.isPinching = false;
        this.initialPinchDistance = null;
        this.initialScale = 1;

        this.el.sceneEl.canvas.addEventListener('touchstart', (e) => {
          if (e.touches.length === 2) {
            this.isPinching = true;
            this.initialPinchDistance = this.getDistance(e.touches);
            this.initialScale = this.el.object3D.scale.x;
          }
        });

        this.el.sceneEl.canvas.addEventListener('touchmove', (e) => {
          if (this.isPinching && e.touches.length === 2) {
            this.handleScale(e);
          } else if (e.touches.length === 1) {
            this.handleRotation(e);
          }
        });

        this.el.sceneEl.canvas.addEventListener('touchend', (e) => {
          if (e.touches.length < 2) {
            this.isPinching = false;
          }
        });
      },
      getDistance(touches) {
        const dx = touches[0].pageX - touches[1].pageX;
        const dy = touches[0].pageY - touches[1].pageY;
        return Math.sqrt(dx * dx + dy * dy);
      },
      handleScale(e) {
        const currentDistance = this.getDistance(e.touches);
        let scale = this.initialScale * (currentDistance / this.initialPinchDistance);
        scale = Math.min(Math.max(scale, this.data.minScale), this.data.maxScale);
        this.el.object3D.scale.set(scale, scale, scale);
      },
      handleRotation(e) {
        const deltaX = e.touches[0].movementX || 0;
        const rotation = this.el.object3D.rotation;
        rotation.y += deltaX * 0.01 * this.data.rotationFactor;
      }
    });
  </script>

  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <a-scene
    embedded
    arjs="sourceType: webcam; debugUIEnabled: false;"
    renderer="logarithmicDepthBuffer: true;"
  >
    <!-- Marker definition (Hiro marker) -->
    <a-marker preset="hiro">
      <!-- 3D Model with gesture interaction -->
      <a-entity
        gesture-handler
        gltf-model="url(https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb)"
        scale="0.5 0.5 0.5"
        position="0 0 0"
        rotation="0 0 0"
      >
      </a-entity>
    </a-marker>

    <!-- AR.js camera -->
    <a-entity camera></a-entity>
  </a-scene>
</body>
</html>
